diff --git a/AndroidManifest.xml b/AndroidManifest.xml
index c812fb6..693d20c 100644
--- a/AndroidManifest.xml
+++ b/AndroidManifest.xml
@@ -2,7 +2,7 @@
         package="com.android.providers.media"
         android:sharedUserId="android.media"
         android:sharedUserLabel="@string/uid_label"
-        android:versionCode="509">
+        android:versionCode="601">
         
     <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
     <uses-permission android:name="android.permission.WRITE_SETTINGS" />
@@ -10,11 +10,14 @@
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
     <uses-permission android:name="android.permission.WRITE_MEDIA_STORAGE" />
     <uses-permission android:name="android.permission.ACCESS_MTP" />
+    <uses-permission android:name="android.permission.MANAGE_USERS" />
+    <uses-permission android:name="android.permission.INTERACT_ACROSS_USERS" />
 
     <application android:process="android.process.media"
-                 android:label="@string/app_label">
+                 android:label="@string/app_label"
+                 android:supportsRtl="true">
         <provider android:name="MediaProvider" android:authorities="media"
-                android:multiprocess="false">
+                android:multiprocess="false" android:exported="true">
             <grant-uri-permission android:pathPrefix="/external/" />
             <path-permission
                     android:pathPrefix="/external/"
@@ -56,12 +59,15 @@
             </intent-filter>
         </service>
 
-        <receiver android:name="UsbReceiver">
+        <receiver android:name=".MtpReceiver">
+            <intent-filter>
+                <action android:name="android.intent.action.BOOT_COMPLETED" />
+            </intent-filter>
             <intent-filter>
                 <action android:name="android.hardware.usb.action.USB_STATE" />
             </intent-filter>
         </receiver>
- 
+
         <service android:name="MtpService" />
 
         <activity android:name="RingtonePickerActivity"
diff --git a/res/values-de/strings.xml b/res/values-de/strings.xml
index e9262ab..8b9da85 100644
--- a/res/values-de/strings.xml
+++ b/res/values-de/strings.xml
@@ -19,5 +19,5 @@
     <string name="uid_label" msgid="999888504096344278">"Medien"</string>
     <string name="app_label" msgid="581696352855930028">"Medienspeicher"</string>
     <string name="upgrade_msg" msgid="4093462661265175619">"Medien-Datenbank wird aktualisiert."</string>
-    <string name="artist_label" msgid="1181678850424271227">"Musiker"</string>
+    <string name="artist_label" msgid="1181678850424271227">"Interpret"</string>
 </resources>
diff --git a/src/com/android/providers/media/MediaProvider.java b/src/com/android/providers/media/MediaProvider.java
index bb21e80..c53d49e 100644
--- a/src/com/android/providers/media/MediaProvider.java
+++ b/src/com/android/providers/media/MediaProvider.java
@@ -91,7 +91,6 @@ import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.PrintWriter;
-import java.text.Collator;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
@@ -103,6 +102,7 @@ import java.util.PriorityQueue;
 import java.util.Stack;
 
 import libcore.io.ErrnoException;
+import libcore.io.IoUtils;
 import libcore.io.Libcore;
 
 /**
@@ -263,9 +263,13 @@ public class MediaProvider extends ContentProvider {
                                 values.put(Files.FileColumns.DATA, "");
                                 String where = FileColumns.STORAGE_ID + "=?";
                                 String[] whereArgs = new String[] { Integer.toString(storage.getStorageId()) };
+                                database.mNumUpdates++;
                                 db.update("files", values, where, whereArgs);
                                 // now delete the records
-                                db.delete("files", where, whereArgs);
+                                database.mNumDeletes++;
+                                int numpurged = db.delete("files", where, whereArgs);
+                                logToDb(db, "removed " + numpurged +
+                                        " rows for ejected filesystem " + storage.getPath());
                                 // notify on media Uris as well as the files Uri
                                 context.getContentResolver().notifyChange(
                                         Audio.Media.getContentUri(EXTERNAL_VOLUME), null);
@@ -563,8 +567,6 @@ public class MediaProvider extends ContentProvider {
         iFilter.addDataScheme("file");
         context.registerReceiver(mUnmountReceiver, iFilter);
 
-        mCaseInsensitivePaths = true;
-
         StorageManager storageManager =
                 (StorageManager)context.getSystemService(Context.STORAGE_SERVICE);
         mExternalStoragePaths = storageManager.getVolumePaths();
@@ -639,6 +641,11 @@ public class MediaProvider extends ContentProvider {
         return true;
     }
 
+    private static final String TABLE_FILES = "files";
+    private static final String TABLE_ALBUM_ART = "album_art";
+    private static final String TABLE_THUMBNAILS = "thumbnails";
+    private static final String TABLE_VIDEO_THUMBNAILS = "videothumbnails";
+
     private static final String IMAGE_COLUMNS =
                         "_data,_size,_display_name,mime_type,title,date_added," +
                         "date_modified,description,picasa_id,isprivate,latitude,longitude," +
@@ -1566,6 +1573,8 @@ public class MediaProvider extends ContentProvider {
                     + FileColumns.MEDIA_TYPE_IMAGE + ";");
         }
 
+        // Honeycomb went up to version 307, ICS started at 401
+
         // Database version 401 did not add storage_id to the internal database.
         // We need it there too, so add it in version 402
         if (fromVersion < 401 || (fromVersion == 401 && internal)) {
@@ -1635,6 +1644,8 @@ public class MediaProvider extends ContentProvider {
             db.execSQL("DELETE FROM audio_genres");
         }
 
+        // ICS went out with database version 409, JB started at 500
+
         if (fromVersion < 500) {
             // we're now deleting the file in mediaprovider code, rather than via a trigger
             db.execSQL("DROP TRIGGER IF EXISTS videothumbnails_cleanup;");
@@ -1723,6 +1734,88 @@ public class MediaProvider extends ContentProvider {
         if (fromVersion < 509) {
             db.execSQL("CREATE TABLE IF NOT EXISTS log (time DATETIME PRIMARY KEY, message TEXT);");
         }
+
+        // Emulated external storage moved to user-specific paths
+        if (fromVersion < 510 && Environment.isExternalStorageEmulated()) {
+            // File.fixSlashes() removes any trailing slashes
+            final String externalStorage = Environment.getExternalStorageDirectory().toString();
+            Log.d(TAG, "Adjusting external storage paths to: " + externalStorage);
+
+            final String[] tables = {
+                    TABLE_FILES, TABLE_ALBUM_ART, TABLE_THUMBNAILS, TABLE_VIDEO_THUMBNAILS };
+            for (String table : tables) {
+                db.execSQL("UPDATE " + table + " SET " + "_data='" + externalStorage
+                        + "'||SUBSTR(_data,17) WHERE _data LIKE '/storage/sdcard0/%';");
+            }
+        }
+        if (fromVersion < 511) {
+            // we update _data in version 510, we need to update the bucket_id as well
+            updateBucketNames(db);
+        }
+
+        // JB 4.2 went out with database version 511, starting next release with 600
+
+        if (fromVersion < 600) {
+            // modify _data column to be unique and collate nocase. Because this drops the original
+            // table and replaces it with a new one by the same name, we need to also recreate all
+            // indices and triggers that refer to the files table.
+            // Views don't need to be recreated.
+
+            db.execSQL("CREATE TABLE files2 (_id INTEGER PRIMARY KEY AUTOINCREMENT," +
+                    "_data TEXT UNIQUE" +
+                    // the internal filesystem is case-sensitive
+                    (internal ? "," : " COLLATE NOCASE,") +
+                    "_size INTEGER,format INTEGER,parent INTEGER,date_added INTEGER," +
+                    "date_modified INTEGER,mime_type TEXT,title TEXT,description TEXT," +
+                    "_display_name TEXT,picasa_id TEXT,orientation INTEGER,latitude DOUBLE," +
+                    "longitude DOUBLE,datetaken INTEGER,mini_thumb_magic INTEGER,bucket_id TEXT," +
+                    "bucket_display_name TEXT,isprivate INTEGER,title_key TEXT,artist_id INTEGER," +
+                    "album_id INTEGER,composer TEXT,track INTEGER,year INTEGER CHECK(year!=0)," +
+                    "is_ringtone INTEGER,is_music INTEGER,is_alarm INTEGER," +
+                    "is_notification INTEGER,is_podcast INTEGER,album_artist TEXT," +
+                    "duration INTEGER,bookmark INTEGER,artist TEXT,album TEXT,resolution TEXT," +
+                    "tags TEXT,category TEXT,language TEXT,mini_thumb_data TEXT,name TEXT," +
+                    "media_type INTEGER,old_id INTEGER,storage_id INTEGER,is_drm INTEGER," +
+                    "width INTEGER, height INTEGER);");
+
+            // copy data from old table, squashing entries with duplicate _data
+            db.execSQL("INSERT OR REPLACE INTO files2 SELECT * FROM files;");
+            db.execSQL("DROP TABLE files;");
+            db.execSQL("ALTER TABLE files2 RENAME TO files;");
+
+            // recreate indices and triggers
+            db.execSQL("CREATE INDEX album_id_idx ON files(album_id);");
+            db.execSQL("CREATE INDEX artist_id_idx ON files(artist_id);");
+            db.execSQL("CREATE INDEX bucket_index on files(bucket_id,media_type," +
+                    "datetaken, _id);");
+            db.execSQL("CREATE INDEX bucket_name on files(bucket_id,media_type," +
+                    "bucket_display_name);");
+            db.execSQL("CREATE INDEX format_index ON files(format);");
+            db.execSQL("CREATE INDEX media_type_index ON files(media_type);");
+            db.execSQL("CREATE INDEX parent_index ON files(parent);");
+            db.execSQL("CREATE INDEX path_index ON files(_data);");
+            db.execSQL("CREATE INDEX sort_index ON files(datetaken ASC, _id ASC);");
+            db.execSQL("CREATE INDEX title_idx ON files(title);");
+            db.execSQL("CREATE INDEX titlekey_index ON files(title_key);");
+            if (!internal) {
+                db.execSQL("CREATE TRIGGER audio_playlists_cleanup DELETE ON files" +
+                        " WHEN old.media_type=4" +
+                        " BEGIN DELETE FROM audio_playlists_map WHERE playlist_id = old._id;" +
+                        "SELECT _DELETE_FILE(old._data);END;");
+                db.execSQL("CREATE TRIGGER files_cleanup DELETE ON files" +
+                        " BEGIN SELECT _OBJECT_REMOVED(old._id);END;");
+            }
+        }
+
+        if (fromVersion < 601) {
+            // remove primary key constraint because column time is not necessarily unique
+            db.execSQL("CREATE TABLE IF NOT EXISTS log_tmp (time DATETIME, message TEXT);");
+            db.execSQL("DELETE FROM log_tmp;");
+            db.execSQL("INSERT INTO log_tmp SELECT time, message FROM log order by rowid;");
+            db.execSQL("DROP TABLE log;");
+            db.execSQL("ALTER TABLE log_tmp RENAME TO log;");
+        }
+
         sanityCheck(db, fromVersion);
         long elapsedSeconds = (SystemClock.currentTimeMicro() - startTime) / 1000000;
         logToDb(db, "Database upgraded from version " + fromVersion + " to " + toVersion
@@ -1733,11 +1826,12 @@ public class MediaProvider extends ContentProvider {
      * Write a persistent diagnostic message to the log table.
      */
     static void logToDb(SQLiteDatabase db, String message) {
-        db.execSQL("INSERT INTO log (time, message) VALUES (datetime('now'),?);",
+        db.execSQL("INSERT OR REPLACE" +
+                " INTO log (time,message) VALUES (strftime('%Y-%m-%d %H:%M:%f','now'),?);",
                 new String[] { message });
         // delete all but the last 500 rows
         db.execSQL("DELETE FROM log WHERE rowid IN" +
-                " (SELECT rowid FROM log ORDER BY time DESC LIMIT 500,-1);");
+                " (SELECT rowid FROM log ORDER BY rowid DESC LIMIT 500,-1);");
     }
 
     /**
@@ -2070,8 +2164,6 @@ public class MediaProvider extends ContentProvider {
             if (!TextUtils.isEmpty(filter)) {
                 String [] searchWords = filter.split(" ");
                 keywords = new String[searchWords.length];
-                Collator col = Collator.getInstance();
-                col.setStrength(Collator.PRIMARY);
                 for (int i = 0; i < searchWords.length; i++) {
                     String key = MediaStore.Audio.keyFor(searchWords[i]);
                     key = key.replace("\\", "\\\\");
@@ -2414,7 +2506,10 @@ public class MediaProvider extends ContentProvider {
                 combine(prependArgs, selectionArgs), groupBy, null, sort, limit);
 
         if (c != null) {
-            c.setNotificationUri(getContext().getContentResolver(), uri);
+            String nonotify = uri.getQueryParameter("nonotify");
+            if (nonotify == null || !nonotify.equals("1")) {
+                c.setNotificationUri(getContext().getContentResolver(), uri);
+            }
         }
 
         return c;
@@ -2448,8 +2543,6 @@ public class MediaProvider extends ContentProvider {
         String [] searchWords = mSearchString.length() > 0 ?
                 mSearchString.split(" ") : new String[0];
         String [] wildcardWords = new String[searchWords.length];
-        Collator col = Collator.getInstance();
-        col.setStrength(Collator.PRIMARY);
         int len = searchWords.length;
         for (int i = 0; i < len; i++) {
             // Because we match on individual words here, we need to remove words
@@ -2542,7 +2635,7 @@ public class MediaProvider extends ContentProvider {
 
     /**
      * Ensures there is a file in the _data column of values, if one isn't
-     * present a new file is created.
+     * present a new filename is generated. The file itself is not created.
      *
      * @param initialValues the values passed to insert by the caller
      * @return the new values
@@ -2559,9 +2652,7 @@ public class MediaProvider extends ContentProvider {
             values = initialValues;
         }
 
-        if (!ensureFileExists(file)) {
-            throw new IllegalStateException("Unable to create new file: " + file);
-        }
+        // we used to create the file here, but now defer this until openFile() is called
         return values;
     }
 
@@ -2730,17 +2821,7 @@ public class MediaProvider extends ContentProvider {
                 return cid;
             }
 
-            // Use "LIKE" instead of "=" on case insensitive file systems so we do a
-            // case insensitive match when looking for parent directory.
-            // TODO: investigate whether a "nocase" constraint on the column and
-            // using "=" would give the same result faster.
-            String selection = (mCaseInsensitivePaths ? MediaStore.MediaColumns.DATA + " LIKE ?1"
-                    // The like above makes it use the index.
-                    // The comparison below makes it correct when the path has wildcard chars
-                    + " AND lower(_data)=lower(?1)"
-                    // search only directories.
-                    + " AND format=" + MtpConstants.FORMAT_ASSOCIATION
-                    : MediaStore.MediaColumns.DATA + "=?");
+            String selection = MediaStore.MediaColumns.DATA + "=?";
             String [] selargs = { parentPath };
             helper.mNumQueries++;
             Cursor c = db.query("files", sIdOnlyColumn, selection, selargs, null, null, null);
@@ -2976,7 +3057,9 @@ public class MediaProvider extends ContentProvider {
                 File file = new File(path);
                 if (file.exists()) {
                     values.put(FileColumns.DATE_MODIFIED, file.lastModified() / 1000);
-                    values.put(FileColumns.SIZE, file.length());
+                    if (!values.containsKey(FileColumns.SIZE)) {
+                        values.put(FileColumns.SIZE, file.length());
+                    }
                 }
             }
 
@@ -3807,6 +3890,7 @@ public class MediaProvider extends ContentProvider {
                             } else if (mediatype == FileColumns.MEDIA_TYPE_AUDIO) {
                                 if (!database.mInternal) {
                                     idvalue[0] =  "" + c.getLong(2);
+                                    database.mNumDeletes += 2; // also count the one below
                                     db.delete("audio_genres_map", "audio_id=?", idvalue);
                                     // for each playlist that the item appears in, move
                                     // all the items behind it forward by one
@@ -3816,6 +3900,7 @@ public class MediaProvider extends ContentProvider {
                                     while (cc.moveToNext()) {
                                         playlistvalues[0] = "" + cc.getLong(0);
                                         playlistvalues[1] = "" + cc.getInt(1);
+                                        database.mNumUpdates++;
                                         db.execSQL("UPDATE audio_playlists_map" +
                                                 " SET play_order=play_order-1" +
                                                 " WHERE playlist_id=? AND play_order>?",
@@ -3953,11 +4038,18 @@ public class MediaProvider extends ContentProvider {
                         count = db.update(sGetTableAndWhereParam.table, initialValues,
                                 sGetTableAndWhereParam.where, whereArgs);
                         if (count > 0) {
-                            // then update the paths of any files and folders contained in the directory.
+                            // update the paths of any files and folders contained in the directory
                             Object[] bindArgs = new Object[] {newPath, oldPath.length() + 1,
-                                    oldPath + "/%", (oldPath.length() + 1), oldPath + "/"};
+                                    oldPath + "/%", (oldPath.length() + 1), oldPath + "/",
+                                    // update bucket_display_name and bucket_id based on new path
+                                    f.getName(),
+                                    f.toString().toLowerCase().hashCode()
+                                    };
                             helper.mNumUpdates++;
                             db.execSQL("UPDATE files SET _data=?1||SUBSTR(_data, ?2)" +
+                                    // also update bucket_display_name
+                                    ",bucket_display_name=?6" +
+                                    ",bucket_id=?7" +
                                     // the "like" test makes use of the index, while the lower()
                                     // test ensures it doesn't match entries it shouldn't when the
                                     // path contains sqlite wildcards
@@ -4174,8 +4266,8 @@ public class MediaProvider extends ContentProvider {
             return 0;
         }
         db.beginTransaction();
+        int numlines = 0;
         try {
-            int numlines = 0;
             helper.mNumUpdates += 3;
             Cursor c = db.query("audio_playlists_map",
                     new String [] {"play_order" },
@@ -4213,13 +4305,17 @@ public class MediaProvider extends ContentProvider {
             db.execSQL("UPDATE audio_playlists_map SET play_order=" + to_play_order +
                     " WHERE play_order=-1 AND playlist_id=" + playlist);
             db.setTransactionSuccessful();
-            Uri uri = MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI
-                    .buildUpon().appendEncodedPath(String.valueOf(playlist)).build();
-            getContext().getContentResolver().notifyChange(uri, null);
-            return numlines;
         } finally {
             db.endTransaction();
         }
+
+        Uri uri = MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI
+                .buildUpon().appendEncodedPath(String.valueOf(playlist)).build();
+        // notifyChange() must be called after the database transaction is ended
+        // or the listeners will read the old data in the callback
+        getContext().getContentResolver().notifyChange(uri, null);
+
+        return numlines;
     }
 
     private static final String[] openFileColumns = new String[] {
@@ -4362,14 +4458,10 @@ public class MediaProvider extends ContentProvider {
                         WRITE_EXTERNAL_STORAGE, "External path: " + path);
             }
 
-            // bypass emulation layer when file is opened for reading, but only
+            // Bypass emulation layer when file is opened for reading, but only
             // when opening read-only and we have an exact match.
-            if (modeBits == MODE_READ_ONLY && Environment.isExternalStorageEmulated()) {
-                final File directFile = new File(Environment.getMediaStorageDirectory(), path
-                        .substring(sExternalPath.length()));
-                if (directFile.exists()) {
-                    file = directFile;
-                }
+            if (modeBits == MODE_READ_ONLY) {
+                file = Environment.maybeTranslateEmulatedPathToInternal(file);
             }
 
         } else if (path.startsWith(sCachePath)) {
@@ -4421,6 +4513,17 @@ public class MediaProvider extends ContentProvider {
         msg.sendToTarget();
     }
 
+    //Return true if the artPath is the dir as it in mExternalStoragePaths
+    //for multi storage support
+    private static boolean isRootStorageDir(String artPath) {
+        for ( int i = 0; i < mExternalStoragePaths.length; i++) {
+            if ((mExternalStoragePaths[i] != null) &&
+                    (artPath.equalsIgnoreCase(mExternalStoragePaths[i])))
+                return true;
+        }
+        return false;
+    }
+
     // Extract compressed image data from the audio file itself or, if that fails,
     // look for a file "AlbumArt.jpg" in the containing directory.
     private static byte[] getCompressedAlbumArt(Context context, String path) {
@@ -4449,7 +4552,6 @@ public class MediaProvider extends ContentProvider {
                 if (lastSlash > 0) {
 
                     String artPath = path.substring(0, lastSlash);
-                    String sdroot = mExternalStoragePaths[0];
                     String dwndir = Environment.getExternalStoragePublicDirectory(
                             Environment.DIRECTORY_DOWNLOADS).getAbsolutePath();
 
@@ -4457,7 +4559,7 @@ public class MediaProvider extends ContentProvider {
                     synchronized (sFolderArtMap) {
                         if (sFolderArtMap.containsKey(artPath)) {
                             bestmatch = sFolderArtMap.get(artPath);
-                        } else if (!artPath.equalsIgnoreCase(sdroot) &&
+                        } else if (!isRootStorageDir(artPath) &&
                                 !artPath.equalsIgnoreCase(dwndir)) {
                             File dir = new File(artPath);
                             String [] entrynames = dir.list();
@@ -4551,6 +4653,9 @@ public class MediaProvider extends ContentProvider {
                 long rowId = db.insert("album_art", MediaStore.MediaColumns.DATA, values);
                 if (rowId > 0) {
                     out = ContentUris.withAppendedId(ALBUMART_URI, rowId);
+                    // ensure the parent directory exists
+                    String albumart_path = values.getAsString(MediaStore.MediaColumns.DATA);
+                    ensureFileExists(albumart_path);
                 }
             } catch (IllegalStateException ex) {
                 Log.e(TAG, "error creating album thumb file");
@@ -4562,29 +4667,22 @@ public class MediaProvider extends ContentProvider {
     // Write out the album art to the output URI, recompresses the given Bitmap
     // if necessary, otherwise writes the compressed data.
     private void writeAlbumArt(
-            boolean need_to_recompress, Uri out, byte[] compressed, Bitmap bm) {
-        boolean success = false;
+            boolean need_to_recompress, Uri out, byte[] compressed, Bitmap bm) throws IOException {
+        OutputStream outstream = null;
         try {
-            OutputStream outstream = getContext().getContentResolver().openOutputStream(out);
+            outstream = getContext().getContentResolver().openOutputStream(out);
 
             if (!need_to_recompress) {
                 // No need to recompress here, just write out the original
                 // compressed data here.
                 outstream.write(compressed);
-                success = true;
             } else {
-                success = bm.compress(Bitmap.CompressFormat.JPEG, 85, outstream);
+                if (!bm.compress(Bitmap.CompressFormat.JPEG, 85, outstream)) {
+                    throw new IOException("failed to compress bitmap");
+                }
             }
-
-            outstream.close();
-        } catch (FileNotFoundException ex) {
-            Log.e(TAG, "error creating file", ex);
-        } catch (IOException ex) {
-            Log.e(TAG, "error creating file", ex);
-        }
-        if (!success) {
-            // the thumbnail was not written successfully, delete the entry that refers to it
-            getContext().getContentResolver().delete(out, null, null);
+        } finally {
+            IoUtils.closeQuietly(outstream);
         }
     }
 
@@ -4663,17 +4761,19 @@ public class MediaProvider extends ContentProvider {
             // that could go wrong while generating the thumbnail, and we only want
             // to update the database when all steps succeeded.
             d.db.beginTransaction();
+            Uri out = null;
+            ParcelFileDescriptor pfd = null;
             try {
-                Uri out = getAlbumArtOutputUri(d.helper, d.db, d.album_id, d.albumart_uri);
+                out = getAlbumArtOutputUri(d.helper, d.db, d.album_id, d.albumart_uri);
 
                 if (out != null) {
                     writeAlbumArt(need_to_recompress, out, compressed, bm);
                     getContext().getContentResolver().notifyChange(MEDIA_URI, null);
-                    ParcelFileDescriptor pfd = openFileHelper(out, "r");
+                    pfd = openFileHelper(out, "r");
                     d.db.setTransactionSuccessful();
                     return pfd;
                 }
-            } catch (FileNotFoundException ex) {
+            } catch (IOException ex) {
                 // do nothing, just return null below
             } catch (UnsupportedOperationException ex) {
                 // do nothing, just return null below
@@ -4682,6 +4782,13 @@ public class MediaProvider extends ContentProvider {
                 if (bm != null) {
                     bm.recycle();
                 }
+                if (pfd == null && out != null) {
+                    // Thumbnail was not written successfully, delete the entry that refers to it.
+                    // Note that this only does something if getAlbumArtOutputUri() reused an
+                    // existing entry from the database. If a new entry was created, it will
+                    // have been rolled back as part of backing out the transaction.
+                    getContext().getContentResolver().delete(out, null, null);
+                }
             }
         }
         return null;
@@ -4909,6 +5016,29 @@ public class MediaProvider extends ContentProvider {
                     int volumeID = FileUtils.getFatVolumeId(path);
                     if (LOCAL_LOGV) Log.v(TAG, path + " volume ID: " + volumeID);
 
+                    // Must check for failure!
+                    // If the volume is not (yet) mounted, this will create a new
+                    // external-ffffffff.db database instead of the one we expect.  Then, if
+                    // android.process.media is later killed and respawned, the real external
+                    // database will be attached, containing stale records, or worse, be empty.
+                    if (volumeID == -1) {
+                        String state = Environment.getExternalStorageState();
+                        if (Environment.MEDIA_MOUNTED.equals(state) ||
+                                Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) {
+                            // This may happen if external storage was _just_ mounted.  It may also
+                            // happen if the volume ID is _actually_ 0xffffffff, in which case it
+                            // must be changed since FileUtils::getFatVolumeId doesn't allow for
+                            // that.  It may also indicate that FileUtils::getFatVolumeId is broken
+                            // (missing ioctl), which is also impossible to disambiguate.
+                            Log.e(TAG, "Can't obtain external volume ID even though it's mounted.");
+                        } else {
+                            Log.i(TAG, "External volume is not (yet) mounted, cannot attach.");
+                        }
+
+                        throw new IllegalArgumentException("Can't obtain external volume ID for " +
+                                volume + " volume.");
+                    }
+
                     // generate database name based on volume ID
                     String dbName = "external-" + Integer.toHexString(volumeID) + ".db";
                     helper = new DatabaseHelper(context, dbName, false,
@@ -5283,7 +5413,7 @@ public class MediaProvider extends ContentProvider {
             }
             if (dumpDbLog) {
                 c = db.query("log", new String[] {"time", "message"},
-                        null, null, null, null, "time");
+                        null, null, null, null, "rowid");
                 try {
                     if (c != null) {
                         while (c.moveToNext()) {
diff --git a/src/com/android/providers/media/MediaScannerReceiver.java b/src/com/android/providers/media/MediaScannerReceiver.java
index fe53a23..0e0d321 100644
--- a/src/com/android/providers/media/MediaScannerReceiver.java
+++ b/src/com/android/providers/media/MediaScannerReceiver.java
@@ -17,28 +17,26 @@
 
 package com.android.providers.media;
 
+import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
-import android.content.BroadcastReceiver;
 import android.net.Uri;
 import android.os.Bundle;
 import android.os.Environment;
 import android.util.Log;
 
-import java.io.File;
-
-
-public class MediaScannerReceiver extends BroadcastReceiver
-{
+public class MediaScannerReceiver extends BroadcastReceiver {
     private final static String TAG = "MediaScannerReceiver";
 
     @Override
     public void onReceive(Context context, Intent intent) {
-        String action = intent.getAction();
-        Uri uri = intent.getData();
-        if (action.equals(Intent.ACTION_BOOT_COMPLETED)) {
-            // scan internal storage
+        final String action = intent.getAction();
+        final Uri uri = intent.getData();
+        if (Intent.ACTION_BOOT_COMPLETED.equals(action)) {
+            // Scan both internal and external storage
             scan(context, MediaProvider.INTERNAL_VOLUME);
+            scan(context, MediaProvider.EXTERNAL_VOLUME);
+
         } else {
             if (uri.getScheme().equals("file")) {
                 // handle intents related to external storage
@@ -46,10 +44,10 @@ public class MediaScannerReceiver extends BroadcastReceiver
                 String externalStoragePath = Environment.getExternalStorageDirectory().getPath();
 
                 Log.d(TAG, "action: " + action + " path: " + path);
-                if (action.equals(Intent.ACTION_MEDIA_MOUNTED)) {
+                if (Intent.ACTION_MEDIA_MOUNTED.equals(action)) {
                     // scan whenever any volume is mounted
                     scan(context, MediaProvider.EXTERNAL_VOLUME);
-                } else if (action.equals(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE) &&
+                } else if (Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action) &&
                         path != null && path.startsWith(externalStoragePath + "/")) {
                     scanFile(context, path);
                 }
@@ -71,5 +69,3 @@ public class MediaScannerReceiver extends BroadcastReceiver
                 new Intent(context, MediaScannerService.class).putExtras(args));
     }    
 }
-
-
diff --git a/src/com/android/providers/media/MediaScannerService.java b/src/com/android/providers/media/MediaScannerService.java
index 99bd734..40bb10a 100644
--- a/src/com/android/providers/media/MediaScannerService.java
+++ b/src/com/android/providers/media/MediaScannerService.java
@@ -85,31 +85,34 @@ public class MediaScannerService extends Service implements Runnable
     }
 
     private void scan(String[] directories, String volumeName) {
+        Uri uri = Uri.parse("file://" + directories[0]);
         // don't sleep while scanning
         mWakeLock.acquire();
 
-        ContentValues values = new ContentValues();
-        values.put(MediaStore.MEDIA_SCANNER_VOLUME, volumeName);
-        Uri scanUri = getContentResolver().insert(MediaStore.getMediaScannerUri(), values);
-
-        Uri uri = Uri.parse("file://" + directories[0]);
-        sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_STARTED, uri));
-        
         try {
-            if (volumeName.equals(MediaProvider.EXTERNAL_VOLUME)) {
-                openDatabase(volumeName);
-            }
+            ContentValues values = new ContentValues();
+            values.put(MediaStore.MEDIA_SCANNER_VOLUME, volumeName);
+            Uri scanUri = getContentResolver().insert(MediaStore.getMediaScannerUri(), values);
 
-            MediaScanner scanner = createMediaScanner();
-            scanner.scanDirectories(directories, volumeName);
-        } catch (Exception e) {
-            Log.e(TAG, "exception in MediaScanner.scan()", e);
-        }
+            sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_STARTED, uri));
+
+            try {
+                if (volumeName.equals(MediaProvider.EXTERNAL_VOLUME)) {
+                    openDatabase(volumeName);
+                }
+
+                MediaScanner scanner = createMediaScanner();
+                scanner.scanDirectories(directories, volumeName);
+            } catch (Exception e) {
+                Log.e(TAG, "exception in MediaScanner.scan()", e);
+            }
 
-        getContentResolver().delete(scanUri, null, null);
+            getContentResolver().delete(scanUri, null, null);
 
-        sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_FINISHED, uri));
-        mWakeLock.release();
+        } finally {
+            sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_FINISHED, uri));
+            mWakeLock.release();
+        }
     }
     
     @Override
@@ -187,7 +190,14 @@ public class MediaScannerService extends Service implements Runnable
         String volumeName = MediaProvider.EXTERNAL_VOLUME;
         openDatabase(volumeName);
         MediaScanner scanner = createMediaScanner();
-        return scanner.scanSingleFile(path, volumeName, mimeType);
+        try {
+            // make sure the file path is in canonical form
+            String canonicalPath = new File(path).getCanonicalPath();
+            return scanner.scanSingleFile(canonicalPath, volumeName, mimeType);
+        } catch (Exception e) {
+            Log.e(TAG, "bad path " + path + " in scanFile()", e);
+            return null;
+        }
     }
 
     @Override
diff --git a/src/com/android/providers/media/MtpReceiver.java b/src/com/android/providers/media/MtpReceiver.java
new file mode 100644
index 0000000..23d529b
--- /dev/null
+++ b/src/com/android/providers/media/MtpReceiver.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.hardware.usb.UsbManager;
+import android.net.Uri;
+import android.os.Bundle;
+
+public class MtpReceiver extends BroadcastReceiver {
+    private final static String TAG = "UsbReceiver";
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        final String action = intent.getAction();
+        if (Intent.ACTION_BOOT_COMPLETED.equals(action)) {
+            final Intent usbState = context.registerReceiver(
+                    null, new IntentFilter(UsbManager.ACTION_USB_STATE));
+            if (usbState != null) {
+                handleUsbState(context, usbState);
+            }
+        } else if (UsbManager.ACTION_USB_STATE.equals(action)) {
+            handleUsbState(context, intent);
+        }
+    }
+
+    private void handleUsbState(Context context, Intent intent) {
+        Bundle extras = intent.getExtras();
+        boolean connected = extras.getBoolean(UsbManager.USB_CONFIGURED);
+        boolean mtpEnabled = extras.getBoolean(UsbManager.USB_FUNCTION_MTP);
+        boolean ptpEnabled = extras.getBoolean(UsbManager.USB_FUNCTION_PTP);
+        // Start MTP service if USB is connected and either the MTP or PTP function is enabled
+        if (connected && (mtpEnabled || ptpEnabled)) {
+            intent = new Intent(context, MtpService.class);
+            if (ptpEnabled) {
+                intent.putExtra(UsbManager.USB_FUNCTION_PTP, true);
+            }
+            context.startService(intent);
+            // tell MediaProvider MTP is connected so it can bind to the service
+            context.getContentResolver().insert(Uri.parse(
+                    "content://media/none/mtp_connected"), null);
+        } else {
+            context.stopService(new Intent(context, MtpService.class));
+            // tell MediaProvider MTP is disconnected so it can unbind from the service
+            context.getContentResolver().delete(Uri.parse(
+                    "content://media/none/mtp_connected"), null, null);
+        }
+    }
+}
diff --git a/src/com/android/providers/media/MtpService.java b/src/com/android/providers/media/MtpService.java
index fce8360..74fd747 100644
--- a/src/com/android/providers/media/MtpService.java
+++ b/src/com/android/providers/media/MtpService.java
@@ -16,6 +16,7 @@
 
 package com.android.providers.media;
 
+import android.app.ActivityManager;
 import android.app.KeyguardManager;
 import android.app.Service;
 import android.content.BroadcastReceiver;
@@ -27,12 +28,11 @@ import android.mtp.MtpDatabase;
 import android.mtp.MtpServer;
 import android.mtp.MtpStorage;
 import android.os.Environment;
-import android.os.Handler;
 import android.os.IBinder;
+import android.os.UserHandle;
 import android.os.storage.StorageEventListener;
 import android.os.storage.StorageManager;
 import android.os.storage.StorageVolume;
-import android.provider.Settings;
 import android.util.Log;
 
 import java.io.File;
@@ -40,6 +40,7 @@ import java.util.HashMap;
 
 public class MtpService extends Service {
     private static final String TAG = "MtpService";
+    private static final boolean LOGD = true;
 
     // We restrict PTP to these subdirectories
     private static final String[] PTP_DIRECTORIES = new String[] {
@@ -50,7 +51,14 @@ public class MtpService extends Service {
     private void addStorageDevicesLocked() {
         if (mPtpMode) {
             // In PTP mode we support only primary storage
-            addStorageLocked(mVolumeMap.get(mVolumes[0].getPath()));
+            final StorageVolume primary = StorageManager.getPrimaryVolume(mVolumes);
+            final String path = primary.getPath();
+            if (path != null) {
+                String state = mStorageManager.getVolumeState(path);
+                if (Environment.MEDIA_MOUNTED.equals(state)) {
+                    addStorageLocked(mVolumeMap.get(path));
+                }
+            }
         } else {
             for (StorageVolume volume : mVolumeMap.values()) {
                 addStorageLocked(volume);
@@ -63,18 +71,29 @@ public class MtpService extends Service {
         public void onReceive(Context context, Intent intent) {
             final String action = intent.getAction();
             if (Intent.ACTION_USER_PRESENT.equals(action)) {
-                synchronized (mBinder) {
-                    // Unhide the storage units when the user has unlocked the lockscreen
-                    if (mMtpDisabled) {
-                        addStorageDevicesLocked();
-                        mMtpDisabled = false;
-                    }
-                }
+                // If the media scanner is running, it may currently be calling
+                // sendObjectAdded/Removed, which also synchronizes on mBinder
+                // (and in addition to that, all the native MtpServer methods
+                // lock the same Mutex). If it happens to be in an mtp device
+                // write(), it may block for some time, so process this broadcast
+                // in a thread.
+                new Thread(new Runnable() {
+                    @Override
+                    public void run() {
+                        synchronized (mBinder) {
+                            // Unhide the storage units when the user has unlocked the lockscreen
+                            if (mMtpDisabled) {
+                                addStorageDevicesLocked();
+                                mMtpDisabled = false;
+                            }
+                        }
+                    }}, "addStorageDevices").start();
             }
         }
     };
 
     private final StorageEventListener mStorageEventListener = new StorageEventListener() {
+        @Override
         public void onStorageStateChanged(String path, String oldState, String newState) {
             synchronized (mBinder) {
                 Log.d(TAG, "onStorageStateChanged " + path + " " + oldState + " -> " + newState);
@@ -93,7 +112,8 @@ public class MtpService extends Service {
     private MtpDatabase mDatabase;
     private MtpServer mServer;
     private StorageManager mStorageManager;
-    private boolean mMtpDisabled; // true if MTP is disabled due to secure keyguard
+    /** Flag indicating if MTP is disabled due to keyguard */
+    private boolean mMtpDisabled;
     private boolean mPtpMode;
     private final HashMap<String, StorageVolume> mVolumeMap = new HashMap<String, StorageVolume>();
     private final HashMap<String, MtpStorage> mStorageMap = new HashMap<String, MtpStorage>();
@@ -101,14 +121,11 @@ public class MtpService extends Service {
 
     @Override
     public void onCreate() {
-        // lock MTP if the keyguard is locked and secure
-        KeyguardManager keyguardManager =
-                (KeyguardManager)getSystemService(Context.KEYGUARD_SERVICE);
-        mMtpDisabled = keyguardManager.isKeyguardLocked() && keyguardManager.isKeyguardSecure();
         registerReceiver(mReceiver, new IntentFilter(Intent.ACTION_USER_PRESENT));
 
-        mStorageManager = (StorageManager)getSystemService(Context.STORAGE_SERVICE);
+        mStorageManager = StorageManager.from(this);
         synchronized (mBinder) {
+            updateDisabledStateLocked();
             mStorageManager.registerListener(mStorageEventListener);
             StorageVolume[] volumes = mStorageManager.getVolumeList();
             mVolumes = volumes;
@@ -116,7 +133,7 @@ public class MtpService extends Service {
                 String path = volumes[i].getPath();
                 String state = mStorageManager.getVolumeState(path);
                 if (Environment.MEDIA_MOUNTED.equals(state)) {
-                   volumeMountedLocked(path);
+                    volumeMountedLocked(path);
                 }
             }
         }
@@ -125,38 +142,64 @@ public class MtpService extends Service {
     @Override
     public int onStartCommand(Intent intent, int flags, int startId) {
         synchronized (mBinder) {
-            if (mServer == null) {
-                mPtpMode = (intent == null ? false
-                        : intent.getBooleanExtra(UsbManager.USB_FUNCTION_PTP, false));
-                Log.d(TAG, "starting MTP server in " + (mPtpMode ? "PTP mode" : "MTP mode"));
-                String[] subdirs = null;
-                if (mPtpMode) {
-                    int count = PTP_DIRECTORIES.length;
-                    subdirs = new String[count];
-                    for (int i = 0; i < count; i++) {
-                        File file =
-                                Environment.getExternalStoragePublicDirectory(PTP_DIRECTORIES[i]);
-                        // make sure this directory exists
-                        file.mkdirs();
-                        subdirs[i] = file.getPath();
-                    }
-                }
-                mDatabase = new MtpDatabase(this, MediaProvider.EXTERNAL_VOLUME,
-                        mVolumes[0].getPath(), subdirs);
-                mServer = new MtpServer(mDatabase, mPtpMode);
-                if (!mMtpDisabled) {
-                    addStorageDevicesLocked();
+            updateDisabledStateLocked();
+            mPtpMode = (intent == null ? false
+                    : intent.getBooleanExtra(UsbManager.USB_FUNCTION_PTP, false));
+            String[] subdirs = null;
+            if (mPtpMode) {
+                int count = PTP_DIRECTORIES.length;
+                subdirs = new String[count];
+                for (int i = 0; i < count; i++) {
+                    File file =
+                            Environment.getExternalStoragePublicDirectory(PTP_DIRECTORIES[i]);
+                    // make sure this directory exists
+                    file.mkdirs();
+                    subdirs[i] = file.getPath();
                 }
-                mServer.start();
             }
+            final StorageVolume primary = StorageManager.getPrimaryVolume(mVolumes);
+            mDatabase = new MtpDatabase(this, MediaProvider.EXTERNAL_VOLUME,
+                    primary.getPath(), subdirs);
+            manageServiceLocked();
         }
 
         return START_STICKY;
     }
 
+    private void updateDisabledStateLocked() {
+        final boolean isCurrentUser = UserHandle.myUserId() == ActivityManager.getCurrentUser();
+        final KeyguardManager keyguardManager = (KeyguardManager) getSystemService(
+                Context.KEYGUARD_SERVICE);
+        mMtpDisabled = (keyguardManager.isKeyguardLocked() && keyguardManager.isKeyguardSecure())
+                || !isCurrentUser;
+        if (LOGD) {
+            Log.d(TAG, "updating state; isCurrentUser=" + isCurrentUser + ", mMtpLocked="
+                    + mMtpDisabled);
+        }
+    }
+
+    /**
+     * Manage {@link #mServer}, creating only when running as the current user.
+     */
+    private void manageServiceLocked() {
+        final boolean isCurrentUser = UserHandle.myUserId() == ActivityManager.getCurrentUser();
+        if (mServer == null && isCurrentUser) {
+            Log.d(TAG, "starting MTP server in " + (mPtpMode ? "PTP mode" : "MTP mode"));
+            mServer = new MtpServer(mDatabase, mPtpMode);
+            if (!mMtpDisabled) {
+                addStorageDevicesLocked();
+            }
+            mServer.start();
+        } else if (mServer != null && !isCurrentUser) {
+            Log.d(TAG, "no longer current user; shutting down MTP server");
+            // Internally, kernel will close our FD, and server thread will
+            // handle cleanup.
+            mServer = null;
+        }
+    }
+
     @Override
-    public void onDestroy()
-    {
+    public void onDestroy() {
         unregisterReceiver(mReceiver);
         mStorageManager.unregisterListener(mStorageEventListener);
     }
@@ -181,8 +224,7 @@ public class MtpService extends Service {
     };
 
     @Override
-    public IBinder onBind(Intent intent)
-    {
+    public IBinder onBind(Intent intent) {
         return mBinder;
     }
 
@@ -193,7 +235,7 @@ public class MtpService extends Service {
                 mVolumeMap.put(path, volume);
                 if (!mMtpDisabled) {
                     // In PTP mode we support only primary storage
-                    if (i == 0 || !mPtpMode) {
+                    if (volume.isPrimary() || !mPtpMode) {
                         addStorageLocked(volume);
                     }
                 }
@@ -206,8 +248,8 @@ public class MtpService extends Service {
         MtpStorage storage = new MtpStorage(volume, getApplicationContext());
         String path = storage.getPath();
         mStorageMap.put(path, storage);
-        
-        Log.d(TAG, "addStorageLocked " + storage.getStorageId() + " " +path);
+
+        Log.d(TAG, "addStorageLocked " + storage.getStorageId() + " " + path);
         if (mDatabase != null) {
             mDatabase.addStorage(storage);
         }
@@ -232,4 +274,3 @@ public class MtpService extends Service {
         }
     }
 }
-
diff --git a/src/com/android/providers/media/RingtonePickerActivity.java b/src/com/android/providers/media/RingtonePickerActivity.java
index 2669fb7..7db1f53 100644
--- a/src/com/android/providers/media/RingtonePickerActivity.java
+++ b/src/com/android/providers/media/RingtonePickerActivity.java
@@ -305,6 +305,13 @@ public final class RingtonePickerActivity extends AlertActivity implements
             if (mDefaultRingtone == null) {
                 mDefaultRingtone = RingtoneManager.getRingtone(this, mUriForDefaultItem);
             }
+           /*
+            * Stream type of mDefaultRingtone is not set explicitly here.
+            * It should be set in accordance with mRingtoneManager of this Activity.
+            */
+            if (mDefaultRingtone != null) {
+                mDefaultRingtone.setStreamType(mRingtoneManager.inferStreamType());
+            }
             ringtone = mDefaultRingtone;
 
             /*
diff --git a/src/com/android/providers/media/UsbReceiver.java b/src/com/android/providers/media/UsbReceiver.java
deleted file mode 100644
index 7a39bc8..0000000
--- a/src/com/android/providers/media/UsbReceiver.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.providers.media;
-
-import android.content.Context;
-import android.content.ContentValues;
-import android.content.Intent;
-import android.content.BroadcastReceiver;
-import android.hardware.usb.UsbManager;
-import android.net.Uri;
-import android.os.Bundle;
-import android.util.Log;
-
-
-public class UsbReceiver extends BroadcastReceiver
-{
-    private final static String TAG = "UsbReceiver";
-
-    @Override
-    public void onReceive(Context context, Intent intent) {
-        Bundle extras = intent.getExtras();
-        boolean connected = extras.getBoolean(UsbManager.USB_CONFIGURED);
-        boolean mtpEnabled = extras.getBoolean(UsbManager.USB_FUNCTION_MTP);
-        boolean ptpEnabled = extras.getBoolean(UsbManager.USB_FUNCTION_PTP);
-        // Start MTP service if USB is connected and either the MTP or PTP function is enabled
-        if (connected && (mtpEnabled || ptpEnabled)) {
-            intent = new Intent(context, MtpService.class);
-            if (ptpEnabled) {
-                intent.putExtra(UsbManager.USB_FUNCTION_PTP, true);
-            }
-            context.startService(intent);
-            // tell MediaProvider MTP is connected so it can bind to the service
-            context.getContentResolver().insert(Uri.parse(
-                    "content://media/none/mtp_connected"), null);
-        } else {
-            context.stopService(new Intent(context, MtpService.class));
-            // tell MediaProvider MTP is disconnected so it can unbind from the service
-            context.getContentResolver().delete(Uri.parse(
-                    "content://media/none/mtp_connected"), null, null);
-        }
-    }
-}
-
-
diff --git a/tools/genfiles/genfiles.sh b/tools/genfiles/genfiles.sh
new file mode 100755
index 0000000..2a139a5
--- /dev/null
+++ b/tools/genfiles/genfiles.sh
@@ -0,0 +1,145 @@
+#!/bin/bash
+
+#
+# Copyright (C) 2011 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+
+
+# This script queries a media provider database, and generates a script to
+# approximately recreate the same file system structure on another device,
+# using dummy files.
+
+EXTERNAL=$2
+if [ "$EXTERNAL" == "" ]
+then
+    EXTERNAL="/storage"
+fi
+
+
+if [ "$ANDROID_HOST_OUT" == "" ]
+then
+    echo "Couldn't find sqlite3. Please run envsetup/lunch and build."
+    exit 1
+fi
+
+if [ "$1" == "" ]
+then
+    echo "Usage: $0 <file.db> [external storage root]"
+    exit 2
+fi
+
+if [ ! -f "$1" ]
+then
+    echo "Couldn't find file $1"
+    exit 3
+fi
+
+# generate script to generate directory structure and content
+$ANDROID_HOST_OUT/bin/sqlite3 $1 "select format, media_type, mime_type, _data from files where _data like '"$EXTERNAL"/%';" | {
+
+MKDIRS=/tmp/mkdirs$$
+CPFILES=/tmp/cpfiles$$
+
+IFS="|"
+while read format mediatype mimetype data;
+do
+    if [ "$format" == "14337" ]
+    then
+        # jpeg
+        echo "cat /storage/sdcard0/proto.jpg > \"$data\"" >> $CPFILES
+    elif [ "$format" == "14347" ]
+    then
+        # png
+        echo "cat /storage/sdcard0/proto.png > \"$data\"" >> $CPFILES
+    elif [ "$format" == "14343" -a "$mediatype" == "0" ]
+    then
+        # gif
+        echo "cat /storage/sdcard0/proto.gif > \"$data\"" >> $CPFILES
+    elif [ "$format" == "12292" -a "$mediatype" == "0" ]
+    then
+        # txt
+        echo "cat /storage/sdcard0/proto.txt > \"$data\"" >> $CPFILES
+    elif [ "$format" == "12293" -a "$mediatype" == "0" ]
+    then
+        # html
+        echo "cat /storage/sdcard0/proto.html > \"$data\"" >> $CPFILES
+    elif [ "$format" == "12297" ]
+    then
+        # mp3
+        echo "cat /storage/sdcard0/proto.mp3 > \"$data\"" >> $CPFILES
+    elif [ "$format" == "12296" ]
+    then
+        # wav
+        echo "cat /storage/sdcard0/proto.wav > \"$data\"" >> $CPFILES
+    elif [ "$format" == "12299" -a "$mediatype" == "0" ]
+    then
+        # m4v
+        echo "cat /storage/sdcard0/proto.m4v > \"$data\"" >> $CPFILES
+    elif [ "$format" == "12299" -a "$mediatype" == "3" ]
+    then
+        # mp4
+        echo "cat /storage/sdcard0/proto.m4v > \"$data\"" >> $CPFILES
+    elif [ "$format" == "12299" -a "$mediatype" == "2" ]
+    then
+        # m4a
+        echo "cat /storage/sdcard0/proto.m4a > \"$data\"" >> $CPFILES
+    elif [ "$format" == "47492" ]
+    then
+        # 3gp
+        echo "cat /storage/sdcard0/proto.3gp > \"$data\"" >> $CPFILES
+    elif [ "$format" == "47362" -a "$mediatype" == "2" ]
+    then
+        # ogg
+        echo "cat /storage/sdcard0/proto.ogg > \"$data\"" >> $CPFILES
+    elif [ "$format" == "12288" -a "$mediatype" == "0" ]
+    then
+        # unknown type
+        echo "cat /storage/sdcard0/proto.dat > \"$data\"" >> $CPFILES
+    elif [ "$format" == "12289" -a "$mediatype" == "0" ]
+    then
+        # directory, ignore
+        true
+    elif [ "$format" == "12288" -a "$mediatype" == "4" ]
+    then
+        # playlist, ignore
+        true
+    else
+        echo ignored: $format '|' $mediatype '|' $mimetype '|' $data
+    fi
+    echo mkdir -p \"$(dirname $data)\" >> $MKDIRS
+done
+
+sort -u $MKDIRS > mkfiles.sh
+cat $CPFILES >> mkfiles.sh
+rm -rf $MKDIRS $CPFILES
+
+}
+
+# generate playlist files
+$ANDROID_HOST_OUT/bin/sqlite3 $1 "select audio_playlists._data, audio._data from audio_playlists left outer join audio_playlists_map on audio_playlists._id=audio_playlists_map.playlist_id left outer join audio on audio_playlists_map.audio_id=audio._id order by audio_playlists_map.playlist_id,audio_playlists_map.play_order;" | {
+
+IFS="|"
+while read plist entry
+do
+    echo "echo \"$(basename $entry)\" >> \"$plist\"" >> mkfiles.sh
+done
+}
+
+echo mkfiles.sh generated. Now run:
+grep sdcard0\/proto mkfiles.sh |sed 's/cat \/storage\/sdcard0\//adb push protos\//' | sed 's/ > .*/ \/storage\/sdcard0\//'|sort -u
+echo adb push mkfiles.sh /storage/sdcard0
+echo adb shell sh /storage/sdcard0/mkfiles.sh
+
diff --git a/tools/genfiles/protos/proto.3gp b/tools/genfiles/protos/proto.3gp
new file mode 100644
index 0000000..4d97f4c
Binary files /dev/null and b/tools/genfiles/protos/proto.3gp differ
diff --git a/tools/genfiles/protos/proto.dat b/tools/genfiles/protos/proto.dat
new file mode 100644
index 0000000..5c3118d
--- /dev/null
+++ b/tools/genfiles/protos/proto.dat
@@ -0,0 +1 @@
+dummy file
diff --git a/tools/genfiles/protos/proto.gif b/tools/genfiles/protos/proto.gif
new file mode 100644
index 0000000..86ead48
Binary files /dev/null and b/tools/genfiles/protos/proto.gif differ
diff --git a/tools/genfiles/protos/proto.html b/tools/genfiles/protos/proto.html
new file mode 100644
index 0000000..eca61de
--- /dev/null
+++ b/tools/genfiles/protos/proto.html
@@ -0,0 +1,6 @@
+<html>
+<head/>
+<body>
+hi!
+</body>
+</html>
diff --git a/tools/genfiles/protos/proto.jpg b/tools/genfiles/protos/proto.jpg
new file mode 100644
index 0000000..64f7439
Binary files /dev/null and b/tools/genfiles/protos/proto.jpg differ
diff --git a/tools/genfiles/protos/proto.m4a b/tools/genfiles/protos/proto.m4a
new file mode 100644
index 0000000..a884dc2
Binary files /dev/null and b/tools/genfiles/protos/proto.m4a differ
diff --git a/tools/genfiles/protos/proto.m4v b/tools/genfiles/protos/proto.m4v
new file mode 100644
index 0000000..c70c244
Binary files /dev/null and b/tools/genfiles/protos/proto.m4v differ
diff --git a/tools/genfiles/protos/proto.mp3 b/tools/genfiles/protos/proto.mp3
new file mode 100644
index 0000000..647ad34
Binary files /dev/null and b/tools/genfiles/protos/proto.mp3 differ
diff --git a/tools/genfiles/protos/proto.ogg b/tools/genfiles/protos/proto.ogg
new file mode 100644
index 0000000..30791a4
Binary files /dev/null and b/tools/genfiles/protos/proto.ogg differ
diff --git a/tools/genfiles/protos/proto.png b/tools/genfiles/protos/proto.png
new file mode 100644
index 0000000..b0bfd4c
Binary files /dev/null and b/tools/genfiles/protos/proto.png differ
diff --git a/tools/genfiles/protos/proto.txt b/tools/genfiles/protos/proto.txt
new file mode 100644
index 0000000..5c3118d
--- /dev/null
+++ b/tools/genfiles/protos/proto.txt
@@ -0,0 +1 @@
+dummy file
diff --git a/tools/genfiles/protos/proto.wav b/tools/genfiles/protos/proto.wav
new file mode 100644
index 0000000..6f14469
Binary files /dev/null and b/tools/genfiles/protos/proto.wav differ
